import random
import math

nb_vehicles = 8
nb_close_stations = 5
total_nb_stations = 11
petitsChevauxList = [[] for x in range(nb_vehicles)]

def isAcceptable(solution):
    problems = []
    cur = 0
    for i in solution:
        occ_nb = solution.count(i)
        if occ_nb > 1:
            problems.append(cur)
        cur += 1
    return problems

#solution_n_weight is a list of pairs of station numbers and weights
def solutionWeight(solution_n_weight):
    weight = 0
    for id_n_weight in solution_n_weight:
        weight += id_n_weight[1]
    return weight

def petitsChevauxList(nb_vehicles, nb_close_stations, total_nb_stations) :

    petits_chevaux_list = [[] for x in range(nb_vehicles)]
    total_station_nb_list = []
    for vehicle in petits_chevaux_list:
        station_nb_list = []
        weight = 0
        for i in range(0,nb_close_stations):
            rand_station_nb = random.randrange(1, total_nb_stations)
            while rand_station_nb in station_nb_list:
                rand_station_nb = random.randrange(1, total_nb_stations)

            if rand_station_nb not in total_station_nb_list:
                total_station_nb_list.append(rand_station_nb)

            station_nb_list.append(rand_station_nb)
            weight += random.random()
            vehicle.append([rand_station_nb, weight])

    print len(total_station_nb_list)
    if len(total_station_nb_list) < nb_vehicles:
        print "not enough stations"
        return petitsChevauxList(nb_vehicles, nb_close_stations, total_nb_stations)
    else:
        return petits_chevaux_list

def createSons(solution, problems, petits_chevaux_list):
    sons = []
    for i in problems:
        prev_station = solution[i]
        index = petits_chevaux_list[i].index(prev_station)
        if index < len(petits_chevaux_list[i])-1:
            next_station = petits_chevaux_list[i][index+1]
            new_son = list(solution)
            new_son[i] = next_station
            sons.append(new_son)
    return sons


#petits_chevaux_list = list of list of pairs generated by the function petitsChevauxList
def petitsChevauxAlg(petits_chevaux_list, max_nb_iter):
    solu = []
    w = float("inf")
    #Initial solution
    s = []
    s_without_weight = []
    for vehicle in petits_chevaux_list:
        s.append(vehicle[0])
        s_without_weight.append(vehicle[0][0])
    s = [s]

    #Compute the number of collisions for the first solution
    init_nb_coll = len(isAcceptable(s_without_weight))
    sol_with_collisions = [[0 , float("inf")] for x in range(init_nb_coll)]
    print init_nb_coll

    print "start"
    minimum_coll_nb = init_nb_coll
    iter = 0
    for sol in s:
        if iter < max_nb_iter:
            sol_without_weight = []
            for i in sol:
                sol_without_weight.append(i[0])
            problems = isAcceptable(sol_without_weight)
            weight = solutionWeight(sol)
            #print "Solution is " + str(sol_without_weight) + " with weight " + str(weight) +  " and problems " + str(problems)
            if len(problems) == 0:
                print "solution found"
                if weight < w:
                    w = weight
                    solu = sol
            elif weight < w:
                #print "extension"
                sons = createSons(sol, problems, petits_chevaux_list)
                s.extend(sons)

            #Store the best solution for the corresponding number of collisions
            id = len(problems)-1
            if id < init_nb_coll:
                if id < minimum_coll_nb:
                    minimum_coll_nb = id
                if weight < sol_with_collisions[id][1]:
                    sol_with_collisions[id][1] = weight
                    sol_with_collisions[id][0] = sol

            iter += 1
            #print iter

    return [solu, weight, sol_with_collisions, minimum_coll_nb]


print petitsChevauxAlg(petitsChevauxList(100, 5, 500), 1e4)
